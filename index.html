<!DOCTYPE html>
<html lang="en">
<head>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Explore the essence and vision of QUADRATICS on the Bitcoin canvas. Join our community and shape the future of Bitcoin's ecosystem.">
  <meta name="robots" content="index, follow, max-snippet:-1, max-video-preview:-1, max-image-preview:large">
  <title>QUADRATICS - Artistic Simplicity Meets Bitcoin Innovation</title>

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://quadratics.io/">
  <meta property="og:title" content="QUADRATICS - Artistic Simplicity Meets Bitcoin Innovation">
  <meta property="og:description" content="Explore the essence and vision of QUADRATICS on the Bitcoin canvas. Join our community and shape the future of Bitcoin's ecosystem.">
  <meta property="og:image" content="https://qdratics.github.io/636.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://quadratics.io/">
  <meta property="twitter:title" content="QUADRATICS - Artistic Simplicity Meets Bitcoin Innovation">
  <meta property="twitter:description" content="Explore the essence and vision of QUADRATICS on the Bitcoin canvas. Join our community and shape the future of Bitcoin's ecosystem.">
  <meta property="twitter:image" content="https://qdratics.github.io/QUADRATICS Banner.png">
</head>
<body>
</body>
</html>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
<style>
/* CSS styles */
html, body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  background: black;
  font-family: 'Courier New', monospace;
}
#matrixBackground {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
  opacity: 0.3;
}
#textContainer {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    text-align: center;
    font-size: 20px; /* Adjust font size if needed */
    line-height: 1.5;
    font-family: 'Orbitron', sans-serif;
    white-space: normal; /* Change from nowrap to normal */
    z-index: 2;
    max-width: 90%; /* Limit the maximum width */
    word-wrap: break-word; /* Ensure long words do not overflow */
}

@media (max-width: 1268px) {
    #textContainer {
        font-size: 16px; /* Smaller font size for mobile */
    }
}
#interactiveGif {
  position: absolute;
  top: 10%; /* Position GIF at the top */
  left: 50%;
  transform: translateX(-50%);
  cursor: pointer;
  z-index: 1;
}
.typing-text {
  display: block;
  margin: 0 0 1,4px;
  opacity: 1;
  font-size: 200px;
}
.cursor {
  display: inline-block;
  background-color: #0F0;
  margin-left: 5px;
  animation: blink 1s infinite;
}
@keyframes blink {
  50% { background-color: transparent; }
}
</style>
</head>
<body>

<canvas id="matrixBackground"></canvas>

<div id="textContainer"></div>

<img src="ezgif-5-fcd51a2524.gif" id="interactiveGif" alt="Animated GIF">

<script>
// Matrix effect JavaScript
document.addEventListener('DOMContentLoaded', (event) => {
    const canvas = document.getElementById('matrixBackground');
    const context = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const katakana = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}';
    const fontSize = 16;
    const columns = canvas.width / fontSize;
    const rainDrops = [];

    // Initialize the rainDrops array with a 0 for each column.
    for (let x = 0; x < columns; x++) {
        rainDrops[x] = 1;
    }

    // Draw the characters
    function drawMatrix() {
        context.fillStyle = 'rgba(0, 0, 0, 0.05)';
        context.fillRect(0, 0, canvas.width, canvas.height);

        context.fillStyle = '#0F0'; // Green text
        context.font = fontSize + 'px monospace';

        for (let i = 0; i < rainDrops.length; i++) {
            const text = katakana.charAt(Math.floor(Math.random() * katakana.length));
            context.fillText(text, i * fontSize, rainDrops[i] * fontSize);
            
            // Randomly reset the end of the column if it's at least 100px high
            if (rainDrops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                rainDrops[i] = 0;
            }
            rainDrops[i]++;
        }
    }

    // Loop the drawMatrix function at 30 frames per second
    setInterval(drawMatrix, 33);
});

// Resize canvas on window resize
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
<script>
  // JavaScript for the typing effect with grouped paragraphs
  (function typingEffect() {
      const paragraphs = [
      "QUADRATICS<br>Simplify to Amplify",
          "// Art in Every Pixel<br>\"The Essence\": Minimalistic. Geometric. Each QUADRATIC is a pixel with purpose on the Bitcoin network.<br>\"The Vision\": Artistic simplicity meets Bitcoin innovation.",
          "// Community Code<br>\"Build on Bitcoin\": QUADRATICS isn't just about ownership, it's about contribution to Bitcoin's ecosystem.<br>\"Power in Numbers\": Inspired by quadratic funding, our community's voice will shape our collective future.",
          "// Back to Bitcoin Basics<br>\"On Bitcoin, Through PIPE\": Leveraging PIPE protocol for straightforward NFT transactions.<br>\"401 Promise\": Art, unity, build, growth. That's QUADRATICS.",
          "// Join the Grid<br>\"Bit by Bit\": Securing a QUADRATIC strengthens the Bitcoin community.<br>\"Community Command\": A collective that values each square in the grid.",
          "// The Square Root<br>\"Keep It Squared\": Complexity is overrated. Look for the beauty of the basics.<br>\"Pixel Power\": Every bit is a building block."

      ];

      let currentParagraph = 0;
      let charIndex = 0;
      let currentText = ''; // Declare currentText outside the type function
      let typingTimeout;

      const typingContainer = document.getElementById('textContainer');
      const cursorSpan = document.createElement('span');
      cursorSpan.classList.add('cursor');
      typingContainer.appendChild(cursorSpan);

      function type() {
          if (charIndex < paragraphs[currentParagraph].length) {
              if (!cursorSpan.classList.contains('typing')) cursorSpan.classList.add('typing');
              const letter = paragraphs[currentParagraph].charAt(charIndex);
              currentText += letter;
              typingContainer.innerHTML = currentText.replace(/\n/g, '<br>'); // Replace \n with <br>
              charIndex++;
              typingTimeout = setTimeout(type, 20);
          } else {
              cursorSpan.classList.remove('typing');
              clearTimeout(typingTimeout);
              setTimeout(erase, 2000); // Wait for 2 seconds before clearing
          }
      }

      function erase() {
          setTimeout(() => {
              typingContainer.innerHTML = '';
              currentText = ''; // Reset currentText when starting a new paragraph
              currentParagraph++;
              if (currentParagraph >= paragraphs.length) currentParagraph = 0;
              charIndex = 0; // Reset charIndex for next paragraph
              setTimeout(type, 1000); // Wait for 1 second before typing the next paragraph
          }, 3000); // Wait for 2 seconds before clearing the text
      }

      setTimeout(type, 500); // Start typing the first paragraph after 500 milliseconds
  })();
</script>
<script>
    document.getElementById('interactiveGif').addEventListener('click', function(e) {
  // Clone the GIF
  var clone = this.cloneNode();
  var maxTop = window.innerHeight;
  var maxLeft = window.innerWidth;
  var randomTop = Math.random() * maxTop;
  var randomLeft = Math.random() * maxLeft;

  // Set initial position for the clone (random position)
  clone.style.position = 'absolute';
  clone.style.top = randomTop + 'px'; // Start from a random vertical position
  clone.style.left = randomLeft + 'px'; // Start from a random horizontal position

  document.body.appendChild(clone);

  // Animate the clone
  var fadeIn = function() {
    var opacity = parseFloat(clone.style.opacity) || 0;
    opacity += 0.02; // Adjust the fading speed as needed
    clone.style.opacity = opacity;
    if (opacity < 1) {
      requestAnimationFrame(fadeIn);
    } else {
      setTimeout(fadeOut, 2000); // Wait for 2 seconds before fading out
    }
  };

  var fadeOut = function() {
    var opacity = parseFloat(clone.style.opacity) || 1;
    opacity -= 0.02; // Adjust the fading speed as needed
    clone.style.opacity = opacity;
    if (opacity > 0) {
      requestAnimationFrame(fadeOut);
    } else {
      clone.remove();
    }
  };

  fadeIn(); // Start the animation
});
    </script>
</body>
</html>
